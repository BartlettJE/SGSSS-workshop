{
  "hash": "e27c563516c7ae82675cf67c49dee70d",
  "result": {
    "markdown": "# Violin-boxplots\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output .cell-output-stderr}\n```\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.3     ✔ readr     2.1.4\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.4.4     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.0\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\nRows: 100 Columns: 7\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (1): id\ndbl (6): age, language, rt_word, rt_nonword, acc_word, acc_nonword\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n:::\n:::\n\n\nThe power of the layered system for making figures is further highlighted by the ability to combine different types of plots. For example, rather than using a bar chart with error bars, you can easily create a single plot that includes the density of the distribution, confidence intervals, means and standard errors. In the below code, we first draw a violin plot, then layer on a boxplot, a point for the mean (note `geom = \"point\"`) and standard error bars (`geom = \"errorbar\"`).\n\n-   `fatten = NULL` in the boxplot geom removes the median line, which can make it easier to see the mean and error bars. Including this argument will result in the message `Removed 1 rows containing missing values (geom_segment)` and is not a cause for concern. Removing this argument will reinstate the median line.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(dat_clean, aes(x = condition, y= rt)) +\n  geom_violin() +\n  # remove the median line with fatten = NULL\n  geom_boxplot(width = .2, \n               fatten = NULL) +\n  stat_summary(fun = \"mean\", geom = \"point\") +\n  stat_summary(fun.data = \"mean_se\", \n               geom = \"errorbar\", \n               width = .1)\n```\n\n::: {.cell-output-display}\n![Violin-boxplot with mean dot and standard error bars.](05-ch5-violin-boxplots_files/figure-html/viobox1-1.png){fig-align='center' width=100%}\n:::\n:::\n\n\nIt is important to note that the order of the layers matters and it is worth experimenting with the order to see where the order matters. For example, if we call `geom_boxplot()` followed by `geom_violin()`, we get the following mess:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(dat_clean, aes(x = condition, y= rt)) +\n  geom_boxplot() +  \n  geom_violin() +\n  stat_summary(fun = \"mean\",  geom = \"point\") +\n  stat_summary(fun.data = \"mean_se\", \n               geom = \"errorbar\", \n               width = .1)\n```\n\n::: {.cell-output-display}\n![Plot with the geoms in the wrong order.](05-ch5-violin-boxplots_files/figure-html/viobox1b-1.png){fig-align='center' width=100%}\n:::\n:::\n\n\n### Grouped violin-boxplots\n\nWe can map multiple variables in the violin-boxplot with the `fill` argument for the violin-boxplot. However, simply adding `fill` to the mapping causes the different components of the plot to become misaligned because they have different default positions:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(dat_clean, aes(x = condition, y= rt, fill = language)) +\n  geom_violin() +\n  geom_boxplot(width = .2, \n               fatten = NULL) +\n  stat_summary(fun = \"mean\",  geom = \"point\") +\n  stat_summary(fun.data = \"mean_se\", \n               geom = \"errorbar\", \n               width = .1)\n```\n\n::: {.cell-output-display}\n![Grouped violin-boxplots without repositioning.](05-ch5-violin-boxplots_files/figure-html/viobox2-1.png){fig-align='center' width=100%}\n:::\n:::\n\n\nTo rectify this, we need to adjust the argument `position` for each of the misaligned layers. `position_dodge()` instructs R to move (dodge) the position of the plot component by the specified value; finding what value looks best can sometimes take trial and error. \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# set the offset position of the geoms\npos <- position_dodge(0.9)\n\nggplot(dat_clean, aes(x = condition, y= rt, fill = language)) +\n  geom_violin(position = pos) +\n  geom_boxplot(width = .2, \n               fatten = NULL, \n               position = pos) +\n  stat_summary(fun = \"mean\", \n               geom = \"point\", \n               position = pos) +\n  stat_summary(fun.data = \"mean_se\", \n               geom = \"errorbar\", \n               width = .1,\n               position = pos)+\n  scale_fill_viridis_d(option=\"B\", begin=0.5, end=0.8)\n```\n\n::: {.cell-output-display}\n![Grouped violin-boxplots with repositioning.](05-ch5-violin-boxplots_files/figure-html/viobox3-1.png){fig-align='center' width=100%}\n:::\n:::\n\n\n## Storing plots\n\nJust like with datasets, plots can be saved to objects. The below code saves the histograms we produced for reaction time and accuracy to objects named `p1` and `p2`. These plots can then be viewed by calling the object name in the console.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\np1 <- ggplot(dat_clean, aes(x = rt)) +\n  geom_histogram(binwidth = 10, color = \"black\")\n\np2 <- ggplot(dat_clean, aes(x = acc)) +\n  geom_histogram(binwidth = 1, color = \"black\") \n```\n:::\n\n\nImportantly, layers can then be added to these saved objects. For example, the below code adds a theme to the plot saved in `p1` and saves it as a new object `p3`. This is important because many of the examples of `ggplot2` code you will find in online help forums use the `p +` format to build up plots but fail to explain what this means, which can be confusing to beginners.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\np3 <- p1 + theme_minimal()\n```\n:::\n\n\n## Saving plots as images\n\nIn addition to saving plots to objects for further use in R, the function `ggsave()` can be used to save plots as images on your hard drive. The plot will be saved to your current working directory, unless you specify an alternative location such as a folder within your current working directory. \n\nThe only required argument for `ggsave` is the file name of the image file you will create, complete with file extension (this can be \"eps\", \"ps\", \"tex\", \"pdf\", \"jpeg\", \"tiff\", \"png\", \"bmp\", \"svg\" or \"wmf\"). By default, `ggsave()` will save the last plot displayed. However, you can also specify a specific plot object if you have one saved.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggsave(filename = \"my_plot.png\") # save last displayed plot\n\nggsave(filename = \"my_plot.png\", plot = p3) # save plot p3\n```\n:::\n\n\nThe width, height and resolution of the image can all be manually adjusted. Fonts will scale with these sizes, and may look different to the preview images you see in the Viewer tab. The help documentation is useful here (type `?ggsave` in the console to access the help).\n",
    "supporting": [
      "05-ch5-violin-boxplots_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}